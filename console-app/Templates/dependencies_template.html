<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Project Dependencies Visualizer - Hub & Spoke</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #1a1a2e; color: #eee; overflow: hidden; }
        #header { position: fixed; top: 0; left: 0; right: 0; background: rgba(22,22,44,0.95); padding: 15px 20px; border-bottom: 2px solid #667eea; z-index: 1000; backdrop-filter: blur(10px); }
        h1 { font-size: 24px; color: #667eea; margin-bottom: 5px; }
        #info { font-size: 13px; color: #aaa; }
        #controls { position: fixed; top: 80px; left: 20px; background: rgba(22,22,44,0.95); padding: 15px; border-radius: 8px; border: 1px solid #667eea; z-index: 1000; max-width: 300px; backdrop-filter: blur(10px); }
        button { background: linear-gradient(135deg,#667eea 0%,#764ba2 100%); color:#fff; border:none; padding:8px 16px; border-radius:5px; cursor:pointer; font-size:13px; margin:5px 5px 5px 0; transition:all .3s ease; }
        button:hover { transform: translateY(-2px); box-shadow:0 4px 8px rgba(102,126,234,.4); }
        #projectList { margin-top:10px; max-height:400px; overflow-y:auto; }
        .project-list-item { padding:8px; margin:5px 0; background: rgba(102,126,234,.2); border-radius:4px; cursor:pointer; font-size:12px; transition:all .2s ease; }
        .project-list-item:hover { background: rgba(102,126,234,.4); transform: translateX(5px); }
        #canvas { position:fixed; top:0; left:0; cursor:grab; }
        #canvas:active { cursor:grabbing; }
        #tooltip { position:fixed; background:rgba(0,0,0,.9); color:#fff; padding:12px; border-radius:6px; border:1px solid #667eea; pointer-events:none; z-index:2000; display:none; max-width:400px; font-size:12px; }
        .tooltip-title { font-weight:bold; font-size:14px; color:#667eea; margin-bottom:8px; }
        .tooltip-item { margin:4px 0; padding:4px 0; border-bottom:1px solid rgba(102,126,234,.3); }
        .tooltip-item:last-child { border-bottom:none; }
        #stats { position:fixed; bottom:20px; right:20px; background: rgba(22,22,44,0.95); padding:10px 15px; border-radius:6px; border:1px solid #667eea; font-size:12px; z-index:1000; }
        ::-webkit-scrollbar { width:8px; }
        ::-webkit-scrollbar-track { background: rgba(0,0,0,.3); }
        ::-webkit-scrollbar-thumb { background:#667eea; border-radius:4px; }
        #projectFilterInput { width:100%; padding:6px 8px; margin:6px 0 10px 0; border:1px solid #667eea; border-radius:5px; background:rgba(102,126,234,.1); color:#eee; font-size:12px; }
        #projectFilterInput:focus { outline:none; box-shadow:0 0 0 2px rgba(102,126,234,.4); }
        .no-matches { color:#888; font-size:12px; font-style:italic; padding:4px 0 12px; }
    </style>
</head>
<body>
    <div id="header">
        <h1>Project Dependencies Visualizer</h1>
        <div id="info">Click on any node to expand its dependencies • Drag to pan • Scroll to zoom</div>
    </div>
    <div id="controls">
        <button onclick="resetView()">Reset View</button>
        <button onclick="clearGraph()">Clear Graph</button>
        <button onclick="toggleProjectList()">Toggle Projects</button>
        <div id="projectList" style="display: none;"></div>
    </div>
    <canvas id="canvas"></canvas>
    <div id="tooltip"></div>
    <div id="stats"></div>
    <script>
        // Dummy data (used if placeholder replacement did not occur)
        const dummyData = {
            "Core": { name: "Core", filePath: "src/Core/Core.csproj", dependencies: ["Logging", "Utils"], metadata: { TargetFramework: "net8.0", OutputType: "Library" } },
            "Logging": { name: "Logging", filePath: "src/Logging/Logging.csproj", dependencies: ["Utils"], metadata: { TargetFramework: "net8.0" } },
            "Utils": { name: "Utils", filePath: "src/Utils/Utils.csproj", dependencies: [], metadata: { TargetFramework: "net8.0" } },
            "Api": { name: "Api", filePath: "src/Api/Api.csproj", dependencies: ["Core"], metadata: { TargetFramework: "net8.0", OutputType: "Exe" } }
        };
        // Placeholder replaced at runtime by HtmlGenerator
        const projectsData = (function(){
            try {
                const data = __PROJECTS_JSON_PLACEHOLDER__;
                if (!data || Object.keys(data).length === 0) return dummyData;
                return data;
            } catch(e){
                return dummyData;
            }
        })();
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const tooltip = document.getElementById('tooltip');
        let width = window.innerWidth; let height = window.innerHeight; canvas.width = width; canvas.height = height;
        let offsetX = 0, offsetY = 0, scale = 1, isDragging = false, lastMouseX = 0, lastMouseY = 0;
        const nodes = new Map();
        const displayedNodes = new Set();
        const expandedNodes = new Set();
        let hoveredNode = null; let selectedNode = null;
        const NODE_WIDTH = 180, NODE_HEIGHT = 50, NODE_PADDING = 10, HUB_DISTANCE = 250;
        const COLORS = { hub:'#667eea', spoke:'#48bb78', expanded:'#ed64a6', selected:'#f59e0b', line:'#4a5568', highlightLine:'#f59e0b', text:'#ffffff', background:'#1a1a2e' };
        class Node { constructor(projectName,x,y,isHub=false){ this.name=projectName; this.x=x; this.y=y; this.vx=0; this.vy=0; this.isHub=isHub; this.project=projectsData[projectName]; }
            draw(){ const screenX=(this.x+offsetX)*scale; const screenY=(this.y+offsetY)*scale; ctx.font=`bold ${13*scale}px 'Segoe UI'`; const textWidth=ctx.measureText(this.name).width; const nodeWidth=Math.max(NODE_WIDTH*scale,textWidth+NODE_PADDING*2*scale); const nodeHeight=NODE_HEIGHT*scale; const cornerRadius=8*scale; const x=screenX-nodeWidth/2; const y=screenY-nodeHeight/2; ctx.beginPath(); ctx.moveTo(x+cornerRadius,y); ctx.lineTo(x+nodeWidth-cornerRadius,y); ctx.quadraticCurveTo(x+nodeWidth,y,x+nodeWidth,y+cornerRadius); ctx.lineTo(x+nodeWidth,y+nodeHeight-cornerRadius); ctx.quadraticCurveTo(x+nodeWidth,y+nodeHeight,x+nodeWidth-cornerRadius,y+nodeHeight); ctx.lineTo(x+cornerRadius,y+nodeHeight); ctx.quadraticCurveTo(x,y+nodeHeight,x,y+nodeHeight-cornerRadius); ctx.lineTo(x,y+cornerRadius); ctx.quadraticCurveTo(x,y,x+cornerRadius,y); ctx.closePath(); if(selectedNode===this){ ctx.fillStyle=COLORS.selected; ctx.shadowBlur=25*scale; ctx.shadowColor=COLORS.selected; } else if(hoveredNode===this){ ctx.fillStyle=COLORS.expanded; ctx.shadowBlur=20*scale; ctx.shadowColor=COLORS.expanded; } else if(this.isHub || expandedNodes.has(this.name)){ ctx.fillStyle=COLORS.hub; ctx.shadowBlur=15*scale; ctx.shadowColor=COLORS.hub; } else { ctx.fillStyle=COLORS.spoke; ctx.shadowBlur=10*scale; ctx.shadowColor=COLORS.spoke; } ctx.fill(); ctx.shadowBlur=0; ctx.strokeStyle=selectedNode===this? '#fbbf24':'#ffffff'; ctx.lineWidth=selectedNode===this? 3*scale:2*scale; ctx.stroke(); ctx.fillStyle=COLORS.text; ctx.font=`bold ${13*scale}px 'Segoe UI'`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(this.name,screenX,screenY-5*scale); if(this.project && this.project.dependencies && this.project.dependencies.length>0){ ctx.font=`${10*scale}px 'Segoe UI'`; ctx.fillStyle='rgba(255,255,255,0.7)'; ctx.fillText(`(${this.project.dependencies.length} deps)`,screenX,screenY+12*scale); } this.width=nodeWidth; this.height=nodeHeight; }
            contains(mouseX,mouseY){ const screenX=(this.x+offsetX)*scale; const screenY=(this.y+offsetY)*scale; const halfWidth=(this.width||NODE_WIDTH*scale)/2; const halfHeight=(this.height||NODE_HEIGHT*scale)/2; return mouseX>=screenX-halfWidth && mouseX<=screenX+halfWidth && mouseY>=screenY-halfHeight && mouseY<=screenY+halfHeight; } }
        function drawLine(x1,y1,x2,y2,isHighlighted=false){ const screenX1=(x1+offsetX)*scale; const screenY1=(y1+offsetY)*scale; const screenX2=(x2+offsetX)*scale; const screenY2=(y2+offsetY)*scale; const lineColor=isHighlighted? COLORS.highlightLine:COLORS.line; const lineWidth=isHighlighted? 4*scale:2*scale; ctx.beginPath(); ctx.moveTo(screenX1,screenY1); ctx.lineTo(screenX2,screenY2); ctx.strokeStyle=lineColor; ctx.lineWidth=lineWidth; ctx.stroke(); const angle=Math.atan2(screenY2-screenY1,screenX2-screenX1); const arrowLength=isHighlighted? 20*scale:15*scale; const arrowWidth=isHighlighted? 10*scale:8*scale; ctx.beginPath(); ctx.moveTo(screenX2,screenY2); ctx.lineTo(screenX2-arrowLength*Math.cos(angle)+arrowWidth*Math.sin(angle),screenY2-arrowLength*Math.sin(angle)-arrowWidth*Math.cos(angle)); ctx.lineTo(screenX2-arrowLength*Math.cos(angle)-arrowWidth*Math.sin(angle),screenY2-arrowLength*Math.sin(angle)+arrowWidth*Math.cos(angle)); ctx.closePath(); ctx.fillStyle=lineColor; ctx.fill(); }
        function expandNode(projectName,recursive=false){ if(!projectsData[projectName]) return; expandedNodes.add(projectName); const hubNode=nodes.get(projectName); if(!hubNode) return; const project=projectsData[projectName]; if(!project.dependencies || project.dependencies.length===0) return; const angleStep=(2*Math.PI)/project.dependencies.length; const newNodes=[]; project.dependencies.forEach((depName,index)=>{ if(displayedNodes.has(depName)) return; const angle=angleStep*index; const x=hubNode.x+Math.cos(angle)*HUB_DISTANCE; const y=hubNode.y+Math.sin(angle)*HUB_DISTANCE; const node=new Node(depName,x,y,false); nodes.set(depName,node); displayedNodes.add(depName); newNodes.push(depName); }); if(recursive){ newNodes.forEach(depName=>expandNode(depName,true)); } }
        function collapseNode(projectName){ expandedNodes.delete(projectName); const project=projectsData[projectName]; if(project && project.dependencies){ project.dependencies.forEach(depName=>{ let isNeededByOther=false; for(const expandedName of expandedNodes){ const expandedProj=projectsData[expandedName]; if(expandedProj && expandedProj.dependencies && expandedProj.dependencies.includes(depName)){ isNeededByOther=true; break; } } if(!isNeededByOther && !expandedNodes.has(depName)){ nodes.delete(depName); displayedNodes.delete(depName); } }); } }
        function render(){ ctx.fillStyle=COLORS.background; ctx.fillRect(0,0,width,height); expandedNodes.forEach(hubName=>{ const hubNode=nodes.get(hubName); if(!hubNode) return; const project=projectsData[hubName]; if(project && project.dependencies){ project.dependencies.forEach(depName=>{ const depNode=nodes.get(depName); if(depNode){ const isHighlighted=selectedNode && (selectedNode.name===hubName || selectedNode.name===depName); drawLine(hubNode.x,hubNode.y,depNode.x,depNode.y,isHighlighted); } }); } }); nodes.forEach(node=>node.draw()); updateStats(); }
        function updateStats(){ const stats=document.getElementById('stats'); stats.innerHTML=`Total Projects: ${Object.keys(projectsData).length}<br>Displayed: ${displayedNodes.size}<br>Expanded: ${expandedNodes.size}`; }
        function showTooltip(node,mouseX,mouseY){ if(!node.project) return; let content=`<div class="tooltip-title">${escapeHtml(node.name)}</div>`; if(node.project.metadata && Object.keys(node.project.metadata).length>0){ for(const [key,value] of Object.entries(node.project.metadata)){ content+=`<div class="tooltip-item"><strong>${escapeHtml(key)}:</strong> ${escapeHtml(value)}</div>`; } } if(node.project.dependencies && node.project.dependencies.length>0){ content+=`<div class="tooltip-item"><strong>Depends on (${node.project.dependencies.length}):</strong><br>${node.project.dependencies.map(d=>escapeHtml(d)).join(', ')}</div>`; } const referredBy=[]; for(const [projName,projData] of Object.entries(projectsData)){ if(projData.dependencies && projData.dependencies.includes(node.name)){ referredBy.push(projName); } } if(referredBy.length>0){ content+=`<div class="tooltip-item"><strong>Referred by (${referredBy.length}):</strong><br>${referredBy.map(r=>escapeHtml(r)).join(', ')}</div>`; } const tooltip=document.getElementById('tooltip'); tooltip.innerHTML=content; tooltip.style.display='block'; tooltip.style.left=(mouseX+15)+'px'; tooltip.style.top=(mouseY+15)+'px'; }
        function hideTooltip(){ const tooltip=document.getElementById('tooltip'); tooltip.style.display='none'; }
        function getNodeAtPosition(mouseX,mouseY){ for(const [name,node] of nodes){ if(node.contains(mouseX,mouseY)) return node; } return null; }
        function showProjectInCenter(projectName,recursive=false){ clearGraph(); const centerX=(width/2-offsetX)/scale; const centerY=(height/2-offsetY)/scale; const node=new Node(projectName,centerX,centerY,true); nodes.set(projectName,node); displayedNodes.add(projectName); expandedNodes.add(projectName); expandNode(projectName,recursive); render(); }
        function resetView(){ offsetX=0; offsetY=0; scale=1; render(); }
        function clearGraph(){ nodes.clear(); displayedNodes.clear(); expandedNodes.clear(); selectedNode=null; render(); }
        function toggleProjectList(){ const list=document.getElementById('projectList'); if(list.style.display==='none'){ list.style.display='block'; renderProjectList(); } else { list.style.display='none'; } }
        // Added filtering support
        const allProjectNames = Object.keys(projectsData).sort();
        function renderProjectList(){ const list=document.getElementById('projectList');
            // Preserve existing filter value if input already exists
            const existingFilterValue = document.getElementById('projectFilterInput')?.value || '';
            list.innerHTML = '<div style="font-weight: bold; margin-bottom: 6px; color: #667eea;">Select a project:</div>' +
                '<input id="projectFilterInput" type="text" placeholder="Filter projects..." value="'+escapeHtml(existingFilterValue)+'" />' +
                '<div id="projectItems"></div>';
            const filterInput = document.getElementById('projectFilterInput');
            filterInput.oninput = () => renderProjectItems(filterInput.value);
            renderProjectItems(existingFilterValue);
        }
        function renderProjectItems(filter){ const itemsContainer=document.getElementById('projectItems'); if(!itemsContainer) return; const lowerFilter = (filter || '').toLowerCase(); let matches = 0; itemsContainer.innerHTML=''; allProjectNames.forEach(projectName=>{ if(lowerFilter && !projectName.toLowerCase().includes(lowerFilter)) return; matches++; const item=document.createElement('div'); item.className='project-list-item'; item.textContent=projectName; item.onclick=()=>showProjectInCenter(projectName); itemsContainer.appendChild(item); }); if(matches === 0){ const empty=document.createElement('div'); empty.className='no-matches'; empty.textContent='No projects match your filter.'; itemsContainer.appendChild(empty);} }
        function escapeHtml(text){ const div=document.createElement('div'); div.textContent=text; return div.innerHTML; }
        const canvasEl=document.getElementById('canvas'); canvasEl.addEventListener('mousedown',e=>{ isDragging=true; lastMouseX=e.clientX; lastMouseY=e.clientY; });
        canvasEl.addEventListener('mousemove',e=>{ if(isDragging){ const dx=e.clientX-lastMouseX; const dy=e.clientY-lastMouseY; offsetX+=dx/scale; offsetY+=dy/scale; lastMouseX=e.clientX; lastMouseY=e.clientY; render(); } else { const node=getNodeAtPosition(e.clientX,e.clientY); if(node!==hoveredNode){ hoveredNode=node; if(node){ showTooltip(node,e.clientX,e.clientY); } else { hideTooltip(); } render(); } else if(node){ const tooltip=document.getElementById('tooltip'); tooltip.style.left=(e.clientX+15)+'px'; tooltip.style.top=(e.clientY+15)+'px'; } } });
        canvasEl.addEventListener('mouseup',()=>{ isDragging=false; });
        canvasEl.addEventListener('click',e=>{ if(Math.abs(e.clientX-lastMouseX)<5 && Math.abs(e.clientY-lastMouseY)<5){ const node=getNodeAtPosition(e.clientX,e.clientY); if(node){ selectedNode=node; if(expandedNodes.has(node.name)){ collapseNode(node.name); } else { node.isHub=true; expandNode(node.name,true); } render(); } } });
        canvasEl.addEventListener('wheel',e=>{ e.preventDefault(); const delta=e.deltaY>0?0.9:1.1; const newScale=scale*delta; if(newScale>=0.1 && newScale<=3){ const mouseX=e.clientX; const mouseY=e.clientY; offsetX=mouseX/scale-mouseX/newScale+offsetX; offsetY=mouseY/scale-mouseY/newScale+offsetY; scale=newScale; render(); } });
        window.addEventListener('resize',()=>{ width=window.innerWidth; height=window.innerHeight; canvas.width=width; canvas.height=height; render(); });
        const projectNames=Object.keys(projectsData); if(projectNames.length>0){ showProjectInCenter(projectNames[0]); }
        toggleProjectList();
    </script>
</body>
</html>